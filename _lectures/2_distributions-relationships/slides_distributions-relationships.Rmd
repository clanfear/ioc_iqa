---
title: "Distributions and Relationships"
subtitle: "IQA Lecture 2"
author: "Charles Lanfear"
date: "19 Oct 2022<br>Updated: `r gsub(' 0', ' ', format(Sys.Date(), format='%d %b %Y'))`"
output:
  xaringan::moon_reader:
    css: "../assets/cam-css.css"
    lib_dir: libs
    nature:
      highlightStyle: tomorrow-night-bright
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "../assets/cam_macros.js"
      titleSlideClass: ["center","top"]
---

```{r setup, purl=FALSE}
#| include: false
options(width = 68)
knitr::opts_chunk$set(eval=TRUE, echo=TRUE, message=TRUE, warning=TRUE, dev = "svg")
```


# Things to include

* Distributions
   * Mean vs. median and skew
      * Logs and log-normals
   * Histograms
   * Barplots?
   * Densities
   * Tables for categoricals
   * skimr?

* Relationships
  * Mean differences between groups
     * Demonstrate conditional distributions
  * Crosstabs
  * Scatterplots
  * Correlations

---

# Today

* News items:
   * Two assessments
      * *Light* data analysis and interpretation
      * One week to complete
   * [Jing's Office Hours](https://us05web.zoom.us/j/84826817691?pwd=cjFnQjBJY1BkOUxvRnBrQy9KbExNQT09): Friday, 12:30-13:30
      * Also by appointment
   * Reschedule Nov 16th to Monday Nov 14th
     * Tentative: 4 PM

--

* Programming

   * Logical expressions
   * `dplyr`

* Statistics

   * Distributions
   * Associations

---
class: inverse

# Logical Expressions

&nbsp;

&nbsp;

![:width 50%](img/spock.gif)

---

# Indexing

Last week we subset or indexed data like so:

```{r}
USArrests[c("California", "Arkansas"), 2:3]
```

This is indexing by **name** or **position**

---

# Indexing by Expression

We can also index using expressionsâ€”logical *tests*.

```{r}
USArrests[USArrests$Murder > 15, ]
```

--

What does this give us?


---

# How Expressions Work

What does `USArrests$Murder > 15` actually do? 

--

```{r}
USArrests$Murder > 15
```

--

It returns a vector of `TRUE` or `FALSE` values.

When used with the subset operator (`[]`), elements for which a `TRUE` is given are returned while those corresponding to `FALSE` are dropped.

--

```{r}
c(1,2,3,4)[c(TRUE, FALSE, TRUE, FALSE)]
```


---

# Logical Operators

We used `>` for testing "greater than": `USArrests$Murder > 15`.

--

There are many other [logical operators](http://www.statmethods.net/management/operators.html):

--
* `==`: equal to

--
* `!=`: not equal to

--
* `>`, `>=`, `<`, `<=`: less than, less than or equal to, etc.

--
* `%in%`: used with checking equal to one of several values

--

Or we can combine multiple logical conditions:

* `&`: both conditions need to hold (AND)
--

* `|`: at least one condition needs to hold (OR)
--

* `!`: inverts a logical condition (`TRUE` becomes `FALSE`, `FALSE` becomes `TRUE`)

--

Logical operators are one of the foundations of programming. You should experiment with these to become familiar with how they work!

---

# And: `&`

![:width 50%](img/murder_and_assault.svg)

```{r}
USArrests[USArrests$Murder > 15 & USArrests$Assault > 300, ]
```



---

# Or: `|`

![:width 50%](img/murder_or_assault.svg)

```{r}
USArrests[USArrests$Murder > 15 | USArrests$Assault > 300, ]
```


---

# Sidenote: Missing Values

Missing values are coded as `NA` entries without quotes:

```{r}
vector_w_missing <- c(1, 2, NA, 4, 5, 6, NA)
```

--

Even one `NA` "poisons the well": You'll get `NA` out of your calculations unless you remove them manually or use the extra argument `na.rm = TRUE` in some functions:

```{r}
mean(vector_w_missing)
```

--

We can take missings (`NA`) and remove (`rm`) them:

```{r}
mean(vector_w_missing, na.rm=TRUE)
```

---
# Finding Missing Values

**WARNING:** You can't test for missing values by seeing if they "equal" (`==`) `NA`:

```{r}
vector_w_missing == NA
```

--

But you can use the `is.na()` function:

```{r}
is.na(vector_w_missing)
```

--

We can use subsetting to get the equivalent of `na.rm=TRUE`:

```{r}
mean(vector_w_missing[!is.na(vector_w_missing)]) #<<
```


.footnote[
`!` *reverses* a logical condition. Read the above as "subset to *not* `NA`"
]

---
class: inverse

# `tidyverse`

&nbsp;

![:width 40%](img/tidyverse.svg)

---

# Installing `tidyverse`

We're going to practice loading files and manipulating data.

--

We will use a packages called `readr` and `dplyr` to do this neatly.

These packages are part of the [`tidyverse`](http://tidyverse.org/) family of R packages

* These packages make using R *much easier*

--

If you have not already installed the tidyverse, type, in the console: `install.packages("tidyverse")`

--

This will install a *large* number of R packages we will use throughout the term, including `readr` and `dplyr`.

---

# Loading Packages

```{r}
library(readr)
library(dplyr)
```

---

# Wait, was that an error?

When you load packages in R that have functions sharing the same name as functions you already have, the more recently loaded functions overwrite the previous ones ("masks them").

--

This **message** is just letting you know that.

--

Sometimes you may get a **warning message** when loading packages---usually because you aren't running the latest version of R:

```
Warning message:
package `dplyr' was built under R version 4.2.2
```

*Update R* to get rid of these!

---
class: inverse
# Importing and Exporting Data

&nbsp;

![:width 40%](img/readr.svg)

---

# Delimited Text Files

One of the most common ways for data to be stored is in a *delimited* text file, e.g. comma-separated values (**.csv**) or tab-separated values (**.tsv**). Here is **.csv** data:

```
"Id","Offense","Sex","Month"
101,"Battery","Male",1,
101,"Battery","Male",1,
101,"Robbery","Male",1,
101,"Battery","Male",2,
101,"Robbery","Male",2,
101,"Homicide","Male",3,
103,"Robbery","Female",1,
103,"Robbery","Female",3,
103,"Battery","Female",4,
```

---
# `readr`

R has a variety of built-in functions for importing delimited text, like `read.table()` and `read.csv()`.

I recommend using the versions in the `readr` package instead: `read_csv()`, `read_tsv()`, and `read_delim()`:

`readr` function features:

* Faster!
* A *little* smarter about dates and times
* Handy function `problems()` you can run if there are errors
* Loading bars for large files

---

# `readr` Importing Example

Let's use `read_csv()` from `readr` to import some data about fatal police shootings from Kaplan (2022).

.small[
```{r}
shootings <- 
  read_csv( 
    "https://clanfear.github.io/ioc_iqa/_data/fatal-police-shootings-data.csv"
    )
```
]

---
class: inverse

# `dplyr`

&nbsp;

![:width 60%](img/dplyr.svg)

---

# Check Out Shootings

`dplyr` gives us access to the handy `glimpse()` for inspecting dataframes.

.text-62[
```{r}

glimpse(shootings)
```
]

---

# But first, pipes!

We can use pipe operators (`|>`) to send data between functions. So instead of nesting functions like this:

```{r}
sort(table(shootings$race))
```

--

We can pipe them like this:

```{r}
shootings$race |> table() |> sort()
```

--

Read this as, "get `shootings$race`, and then make a `table()`, and then `sort()` it."
In essence, pipes read "left to right" while nested functions read "inside to out."

---

# `filter` Data Frames

```{r}
shootings |> filter(armed == "unarmed") |> head()
```

.text-center[
*What is this doing?*
]

.footnote[
Note that `dplyr` hides excess columns from output so it fits the console!
]

---

# `filter`

`filter()` is `dplyr`'s function for indexing **rows** of a dataframe

--

It takes *only* logical vectors (the result of **expressions**) as an argument

--

If you want to `filter()` by *position*, use `slice()`:

```{r}
shootings |> slice(c(1, 5, 9))
```


---
# Multiple Conditions

.pull-left[

### And: `&`

```{r, eval=FALSE}
shootings |>
    filter(armed == "unarmed" & 
             age < 18)
```

.image-100[
![](img/armed_and_age.svg)
]

*Give me rows where the subject was unarmed **and** their age is under 18.*

]

--

.pull-right[

### Or: `|`

```{r, eval=FALSE}
shootings |>
    filter(armed == "unarmed" |
          age < 18)
```

.image-100[
![](img/armed_or_age.svg)
]

*Give me rows where the subject was unarmed **or** their age is under 18... or **both**.*

]

---
class: inverse

# Distributions

---

# London Crime

We'll revisit the shootings data again soon.

For now, let's load another example dataset: 

Metropolitan Police recorded crime in London boroughs in 2021

```{r}
metro_2021 <- read_csv("https://clanfear.github.io/ioc_iqa/_data/metro_2021.csv")
```

---

# Counting

We used `table()` earlier to tabulate a categorical variable

In `dplyr`, we can use `count()`

```{r}
shootings |> count(armed) |> arrange(desc(n))
```





---
class: inverse

# Plotting

![:width 60%](img/ggplot2.svg)



---

# London Crime


```{r}
glimpse(metro_2021)
```

---



---

# Saving a Subset

If we think a particular subset will be used repeatedly, we can save it and give it a name like any other object:

```{r}
westminster <- metro_2021 |> filter(borough == "Westminster")
head(westminster, 4)
```

---

## Base R Plots from Last Week

.pull-left[
 .small[
```{r base-plot, fig.show='hide'}
plot(robbery ~ month, 
     data = westminster, 
     xlab = "Month", 
     ylab = "Robbery",
     main = 
       "Robbery in Westminster", 
     col = "red", 
     cex.lab = 1.5,
     cex.main= 1.5,
     pch = 16)
```
 ]
]

.pull-right[
![](`r knitr::fig_chunk("base-plot", "svg")`)
]

---

# `ggplot2`
  
An alternative way of plotting many prefer (myself included)<sup>1</sup> uses the `ggplot2` package in R, which is part of the `tidyverse`.

.footnote[[1] [Though this is not without debate](http://simplystatistics.org/2016/02/11/why-i-dont-use-ggplot2/)]

```{r}
library(ggplot2)
```

The core idea underlying this package is the [**layered grammar of graphics**](https://doi.org/10.1198/jcgs.2009.07098): we can break up elements of a plot into pieces and combine them.

---

## Chinese Life Expectancy in `ggplot`
  
.pull-left[
```{r westminster-gg,  fig.show='hide'}
ggplot(data = westminster, 
        aes(x = month, y = robbery)) +
  geom_point()
```
]

.pull-right[
![](`r knitr::fig_chunk("westminster-gg", "svg")`)
]

---

# Structure of a ggplot
  
`ggplot2` graphics objects consist of two primary components:
  
--
  
1. **Layers**, the components of a graph.

* We *add* layers to a `ggplot2` object using `+`.
* This includes lines, shapes, and text.

--
  
2. **Aesthetics**, which determine how the layers appear.

* We *set* aesthetics using *arguments* (e.g. `color="red"`) inside layer functions.
* This includes locations, colors, and sizes.
* Aesthetics also determine how data *map* to appearances.

---
  
# Layers
  
**Layers** are the components of the graph, such as:
  
* `ggplot()`: The initial plot canvas
* `geom_point()`: Scatterplot points
* `geom_line()`: Lines between data points
* `labs()`: Plot title and axis labels
* `facet_wrap()`: Divides plot into a sequence of panels
* `facet_grid()`: Divides plot into a grid of plot panels
* `theme_bw()`: Replace default gray background with black-and-white

Layers are separated by a `+` sign.

---
  
# Aesthetics
  
**Aesthetics** control the appearance of the layers:
  
* `x`, `y`: $x$ and $y$ coordinate values to use
* `color`: Color of elements based on some data value
* `group`: Describe which data points are grouped together (often used with lines)
* `size`: Size of points/lines based on some data value
* `alpha`: Transparency based on some data value

---
  
## Aesthetics: Setting vs. mapping
  
Layers take arguments to control their appearance, such as point/line colors or transparency (`alpha` between 0 and 1).

--
  
* Arguments like `color`, `size`, `linetype`, `shape`, `fill`, and `alpha` can be used directly on the layers (**setting aesthetics**), e.g. `geom_point(color = "red")`. See the [`ggplot2` documentation](https://ggplot2.tidyverse.org/reference/index.html) for options. These *don't depend on the data*.

--

* Arguments inside `aes()` (**mapping aesthetics**) will *depend on the data*, e.g. `geom_point(aes(color = continent))`.

--

* `aes()` in the `ggplot()` layer gives overall aesthetics to use in other layers, but can be changed on individual layers (including switching `x` or `y` to different variables)

--

This may seem pedantic, but precise language makes searching for help easier.

--

Now let's see all this jargon in action.

---

## Axis Labels, Points, No Background

### 1: Base Plot

.pull-left[
```{r westminster-1, fig.height=4, fig.show='hide'}
ggplot(data = westminster,  #<<
       aes(x = month, y = robbery)) #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-1", "svg")`)
]

.footnote[Initialize the plot with `ggplot()` and `x` and `y` aesthetics **mapped** to variables.]

---

## Axis Labels, Points, No Background

### 2: Scatterplot

.pull-left[
```{r westminster-2, fig.height=4, fig.show='hide'}
ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
    geom_point() #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-2", "svg")`)
]

.footnote[Add a scatterplot **layer**.]

---

## Axis Labels, Points, No Background

### 3: Point Color and Size

.pull-left[
```{r westminster-3, fig.height=4, fig.show='hide'}
ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-3", "svg")`)
]

.footnote[**Set** aesthetics to make the points large and red.]

---

## Axis Labels, Points, No Background

### 4: X-Axis Label

.pull-left[
```{r westminster-4, fig.height=4, fig.show='hide'}
ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) +
  xlab("Month") #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-4", "svg")`)
]

.footnote[Add a layer to capitalize the x-axis label.]

---

## Axis Labels, Points, No Background

### 5: Y-Axis Label

.pull-left[
```{r westminster-5, fig.height=4, fig.show='hide'}
ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) +
  xlab("Month") + 
  ylab("Robbery") #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-5", "svg")`)
]

.footnote[Add a layer to clean up the y-axis label.]

---

## Axis Labels, Points, No Background

### 6: Title

.pull-left[
```{r westminster-6, fig.height=4, fig.show='hide'}
ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) +
  xlab("Month") + 
  ylab("Robbery") +
   ggtitle("Robbery in Westminster") #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-6", "svg")`)
]

.footnote[Add a title layer.]

---

## Axis Labels, Points, No Background

### 7: Theme

.pull-left[
```{r westminster-7, fig.height=4, fig.show='hide'}
ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) +
  xlab("Month") + 
  ylab("Robbery") +
  ggtitle("Robbery in Westminster") +
  theme_bw() #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-7", "svg")`)
]

.footnote[Pick a basic theme with a new layer.]

---

## Axis Labels, Points, No Background

### 8: Text Size

.pull-left[
```{r westminster-8, fig.height=4, fig.show='hide'}
 ggplot(data = westminster, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) +
  xlab("Month") + 
  ylab("Robbery") +
  ggtitle("Robbery in Westminster") +
   theme_bw(base_size=18) #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-8", "svg")`)
]

.footnote[Increase the base text size.]

---

# Plotting All Boroughs
  
We have a plot we like for Westminster... 

... but what if we want *all the boroughs*?
  
---

# Plotting All Countries

### 1: A Mess!

.pull-left[
```{r london-1, fig.height=4, fig.show='hide'}
 ggplot(data = metro_2021, 
      aes(x = month, y = robbery)) +
  geom_point(color = "red", size = 3) +
  xlab("Month") + 
  ylab("Robbery") +
  ggtitle("Robbery in London") +
   theme_bw(base_size=18) #<<
```
]
.pull-right[
![](`r knitr::fig_chunk("westminster-8", "svg")`)
]

.footnote[We can't tell countries apart! Maybe we could follow *lines*?]

---


# Plotting All Countries

### 2: Lines
.pull-left[
 .small[
```{r, fig.height=4, dev='svg', eval=FALSE}
ggplot(data = gapminder, 
       aes(x = year, y = lifeExp)) +
  geom_line(color = "red", size = 3) + #<<
  xlab("Year") + 
  ylab("Life expectancy") +
  ggtitle("Life expectancy over time") +
  theme_bw(base_size=18)
```
]
]
.pull-right[
```{r,  dev='svg', echo=FALSE}
ggplot(data = gapminder, 
       aes(x = year, y = lifeExp)) +
  geom_line(color = "red", size = 3) + #<<
  xlab("Year") + 
  ylab("Life expectancy") +
  ggtitle("Life expectancy over time") +
  theme_bw(base_size=18)
```
]

.footnote[`ggplot2` doesn't know how to connect the lines!]

---
  
  
  # Plotting All Countries
  
  ### 3: Grouping
  .pull-left[
    .small[
      ```{r, fig.height=4, dev='svg', eval=FALSE}
      ggplot(data = gapminder, 
             aes(x = year, y = lifeExp, 
                 group = country)) + #<<
        geom_line(color = "red", size = 3) +
        xlab("Year") + 
        ylab("Life expectancy") +
        ggtitle("Life expectancy over time") +
        theme_bw(base_size=18)
      ```
    ]
  ]
.pull-right[
  ```{r,  dev='svg', echo=FALSE}
  ggplot(data = gapminder, 
         aes(x = year, y = lifeExp, 
             group = country)) + #<<
    geom_line(color = "red", size = 3) +
    xlab("Year") + 
    ylab("Life expectancy") +
    ggtitle("Life expectancy over time") +
    theme_bw(base_size=18)
  ```
]

.footnote[That looks more reasonable... but the lines are too thick!]
---
  
  
  # Plotting All Countries
  
  ### 4: Size
  .pull-left[
    .small[
      ```{r, fig.height=4, dev='svg', eval=FALSE}
      ggplot(data = gapminder, 
             aes(x = year, y = lifeExp, 
                 group = country)) +
        geom_line(color = "red") + #<<
        xlab("Year") + 
        ylab("Life expectancy") +
        ggtitle("Life expectancy over time") +
        theme_bw(base_size=18)
      ```
    ]
  ]
.pull-right[
  ```{r,  dev='svg', echo=FALSE}
  ggplot(data = gapminder, 
         aes(x = year, y = lifeExp, 
             group = country)) +
    geom_line(color = "red") + #<<
    xlab("Year") + 
    ylab("Life expectancy") +
    ggtitle("Life expectancy over time") +
    theme_bw(base_size=18)
  ```
]

.footnote[Much better... but maybe we can do highlight regional differences?]

---
  
  
  # Plotting All Countries
  
  ### 5: Color
  .pull-left[
    .small[
      ```{r, fig.height=4, dev='svg', eval=FALSE}
      ggplot(data = gapminder, 
             aes(x = year, y = lifeExp, 
                 group = country, 
                 color = continent)) + #<<
        geom_line() + #<<
        xlab("Year") + 
        ylab("Life expectancy") +
        ggtitle("Life expectancy over time") +
        theme_bw(base_size=18)
      ```
    ]
  ]
.pull-right[
  ```{r,  dev='svg', echo=FALSE}
  ggplot(data = gapminder, 
         aes(x = year, y = lifeExp, 
             group = country, 
             color = continent)) + #<<
    geom_line() + #<<
    xlab("Year") + 
    ylab("Life expectancy") +
    ggtitle("Life expectancy over time") +
    theme_bw(base_size=18) #<<
  ```
]

.footnote[Patterns are obvious... but why not separate continents completely?]

---


---
  
  # Wrap-Up
  
  * Reading for next week

* `swirl` units

