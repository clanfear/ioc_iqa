<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Charles Lanfear" />
    <script src="libs/header-attrs-2.16/header-attrs.js"></script>
    <link rel="stylesheet" href="../assets/cam-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, top, title-slide

.title[
# Introduction to R
]
.subtitle[
## IQA Lecture 0
]
.author[
### Charles Lanfear
]
.date[
### 6 Oct 2022<br>Updated: 5 Oct 2022
]

---





# Course Goals


* Cultivate basic competence with applied statistics

  * *We'll start this next week*

--

* Develop intermediate R data management and visualization skills

  * *We'll start this today*

--

* Prepare you for advanced topics in quantitative analysis


--

* Introduce reproducible research practices

---
class: inverse

.text-align-center[
# Why are you doing this to me?
]

---

# Reasons

--

### You *will* read quantitative research

* Interpretation
* Evaluation

--

### You *may* do quantitative research

* Analysis
* Reporting

--

Pratt (2015):

.text-72[
&gt; And another good reason to have a strong – and more importantly, eclectic – methodological skill‐set is so that you will not have to define (and therefore confine) yourself as either a quantitative or qualitative criminologist (although some people enthusiastically embrace such labels). You can instead call yourself a criminologist and be safe in the knowledge that you have command of whatever methodological “tool” you will need to answer whatever criminological question you have decided to ask.

]


---
class: inverse

.text-align-center[
# Okay, but programming?
]

---
# Data *analysis* is mostly data *wrangling*

.footnote[Credit: Kieran Healy]

--

&amp;nbsp;

## Data wrangling is **frustrating**

---
class: inverse

# Well, can we make it fun?

---


.text-big-center[
**NO**
]

---
class: inverse

# Can we at least make it not frustrating?

---

.text-big-center[
**ALSO&lt;br&gt;NO**
]

---
# Programming is *important*

* Cleaning data by hand is:

  * Error prone
  * Time consuming
  * Not **reproducible**

--

* It opens *many* doors

  * New avenues of research
  * Non-academic jobs
  * Side hustles
  * Improved work flows *even without data*

--

.pull-left[
The frustration is *always* present...
]

--

.pull-right[
but you get used to it
]

---

# Logistics

Location: Computer Lab, Wed, 14:00-16:00

Jing's email: [ss2826@cam.ac.uk]()

* Your first point of contact for troubleshooting!

My email: [cl948@cam.ac.uk]()

* For non-troubleshooting questions---or *really* broken stuff

My drop-in times:

* 3.9, Tue, 14:00-15:00
* 3.9, Wed, 11:00-12:00

---

# Materials

All course materials are on the course website: [http://clanfear.github.io/ioc_iqa](). 

This includes:

* These slides and the code used to generate them.
* An R script for the slides to follow along in class.
* Useful links to other resources.
* **Formative assignments**

If something doesn't work, email me.

---

# A Note on Slide Formatting

**Bold** is an important term.

--

*Italics* are emphasis or mouse-click instructions

* "Click *File \&gt; Print*"

--

`Code` is R code you type in or keystrokes for actions

* "Press `Ctrl-P` to open the print dialogue."

--

Code chunks are *actual embedded R code*.


```r
*# Sometimes important stuff is highlighted!
7 * 49
```

```
## [1] 343
```

--

`##` indicates the output from running the code chunk.

---
class: inverse

# R and RStudio

---

# Why R?

R is a programming language built for statistical computing.

If one already knows Excel, SPSS, or Stata, why use R?

--

* R is *free*, so you don't need a terminal server or license.

--

* R has a *very* large community for support and packages.

--

* R can handle virtually any data format.

--

* R makes replication *easy*.

--

* R is a *language* so it can do *everything*.&lt;sup&gt;1&lt;/sup&gt;

.footnote[[1] Including making these slides and the course webpage.]

--

* R is similar to other programming languages.


---

# R Studio

R Studio is a "front-end" or integrated development environment (IDE) for R that can make your life *easier*.

--

We'll show RStudio can...

* Organize your code, output, and plots

--

* Auto-complete code and highlight syntax

--

* Help view data and objects

--

* Enable easy integration of R code into documents with **Quarto** and **RMarkdown**

--

It can also...

* Manage `git` repositories

* Run interactive tutorials

* Handle other languages like Python, SQL, and HTML

---

# Getting Started

Open up RStudio now and choose *File \&gt; New File \&gt; R Script*.

Then, let's get oriented with the interface:

--

* *Top Left*: Code **editor** pane, data viewer (browse with tabs)

--

* *Bottom Left*: **Console** for running code (`&gt;` prompt)

--

* *Top Right*: List of objects in **environment**, code **history** tab.

--

* *Bottom Right*: Tabs for browsing files, viewing plots, managing packages, and viewing help files.

--

You can change the layout in *Preferences \&gt; Pane Layout*

---

# Editing and Running Code

There are several ways to run R code in RStudio:

--

* Highlight lines in the **editor** window and click *Run* at the top or hit `Ctrl+Enter` or `⌘+Enter` to run them all.

--

* With your **caret** (.blink[`|`]) on a line you want to run, hit `Ctrl+Enter` or `⌘+Enter`. Note your caret moves to the next line, so you can run code sequentially with repeated presses.

--

* Type individual lines in the **console** and press `Enter`.

The console will show the lines you ran followed by any printed output.

---

# Incomplete Code

If you mess up (e.g. leave off a parenthesis), R might show a `+` sign prompting you to finish the command:


```r
&gt; (11-2
+
```

Finish the command or hit `Esc` to get out of this.

---

# R as a Calculator

In the **console**, type `123 + 456 + 789` and hit `Enter`.

--


```r
123 + 456 + 789
```

```
## [1] 1368
```

--

The `[1]` in the output indicates the numeric **index** of the first element on that line.

--

Now in your blank R document in the **editor**, try typing the line `sqrt(400)` and either clicking *Run* or hitting `Ctrl+Enter` or `⌘+Enter`.

--


```r
sqrt(400)
```

```
## [1] 20
```

---
# Functions and Help

`sqrt()` is an example of a **function** in R.

--

If we didn't have a good guess as to what `sqrt()` will do, we can type `?sqrt` in the console and look at the **Help** panel on the right.


```r
?sqrt
```

--

**Arguments** are the *inputs* to a function. In this case, the only argument to `sqrt()` is `x` which can be a number or a vector of numbers.

Help files provide documentation on how to use functions and what functions produce.

---

# Creating Objects

R stores *everything* as an **object**, including data, functions, models, and output.

--

Creating an object can be done using the **assignment operator**: `&lt;-`

--


```r
new.object &lt;- 144
```

--

**Operators** like `&lt;-` are functions that look like symbols but typically sit between their arguments (e.g. numbers or objects) instead of having them inside `()` like in `sqrt(x)`.&lt;sup&gt;1&lt;/sup&gt;

.footnote[[1] We can call operators like other functions using backticks: &lt;code&gt;\`+\`(x,y)&lt;/code&gt;]

--

We do math with operators, e.g., `x + y`. `+` is the addition operator!

---

# Calling Objects

You can display or "call" an object simply by using its name.


```r
new.object
```

```
## [1] 144
```

--

Object names can contain `_` and `.` in them, but cannot *begin* with numbers. Try to be consistent in naming objects.

--

Auto-complete means *long names are better than vague ones*!

*Good names*&lt;sup&gt;1&lt;/sup&gt; save confusion later.

.footnote[[1] *"There are only two hard things in Computer Science: cache invalidation and naming things." - Phil Karlton*]

---

# Using Objects

You can treat the object's **name** as if it were the values stored inside.

--


```r
new.object + 10
```

```
## [1] 154
```

```r
new.object + new.object
```

```
## [1] 288
```

```r
sqrt(new.object)
```

```
## [1] 12
```

---

# Creating Vectors

A **vector** is a series of **elements**, such as numbers.

--

You can create a vector using the function `c()` which stands for "combine".

--


```r
new.object &lt;- c(4, 9, 16, 25, 36)
new.object
```

```
## [1]  4  9 16 25 36
```

--

Assigning to an existing name *overwrites that object*.

--

You can provide a vector as an argument for many functions.

--


```r
sqrt(new.object)
```

```
## [1] 2 3 4 5 6
```

---

# Character Vectors

We often work with data that are categorical. To create a vector of text elements—**strings** in programming terms—we must place the text in quotes:


```r
string.vector &lt;- c("Atlantic", "Pacific", "Arctic")
string.vector
```

```
## [1] "Atlantic" "Pacific"  "Arctic"
```

--

Categorical data can also be stored as a **factor**, which has an underlying numeric representation.&lt;sup&gt;1&lt;/sup&gt;


```r
factor.vector &lt;- factor(string.vector)
factor.vector
```

```
## [1] Atlantic Pacific  Arctic  
## Levels: Arctic Atlantic Pacific
```

.footnote[[1] Factors have **levels** which you can use to set a reference category in models using `relevel()`. We'll use this in a few weeks.]

---
# Saving and Loading Objects

You can save an R object on your computer as a file to open later:

```r
save(new.object, file="new_object.RData")
```

--

You can open saved files in R as well:

```r
load("new_object.RData")
```

--

But where are these files being saved and loaded from?

---

# Working Directories

R saves files and looks for files to open in your current **working directory**&lt;sup&gt;1&lt;/sup&gt;. You
can ask R what this is:

.footnote[[1] For a simple R function to open an Explorer / Finder window at your working directory, [see this StackOverflow response](https://stackoverflow.com/a/12135823/10277284).]


```r
getwd()
```

```
## [1] "C:/Users/cclan/OneDrive/GitHub/ioc_iqa/_lectures/0_intro-to-r"
```

--

Similarly, we can set a working directory like so:


```r
setwd("C:/Users/")
```

---

# More Complex Objects

The same principles can be used to create more complex objects:

* **matrices**
* **arrays**
* **lists**
* **dataframes**

--

Most data sets you will work with will be read into R and stored as a **dataframe**. 

Consequently, we will focus on manipulating and analyzing these dataframes.

---
class: inverse

# Data Frames

---

# What's Up with `USArrests`?

In our R script, let's load the built-in dataframe `USArrests`. 

--


```r
data(USArrests)
```


`data(USArrests)` loads this dataframe into the **Global Environment** (as a *promise*&lt;sup&gt;1&lt;/sup&gt;).

.footnote[[1] Promises are *unevaluated arguments*. Read more about R's [lazy evaluation here](http://adv-r.had.co.nz/Functions.html).]

--

`View(cars)` pops up a **Viewer** pane ("interactive" use only, don't put in R Markdown document!) or...

--


```r
head(USArrests, 5) # prints first 5 rows, see tail() too
```

```
##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
```

---

# More About `USArrests`

`str()` displays the structure of an object:

.text-85[

```r
str(USArrests) # str[ucture]
```

```
## 'data.frame':	50 obs. of  4 variables:
##  $ Murder  : num  13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ...
##  $ Assault : int  236 263 294 190 276 204 110 238 335 211 ...
##  $ UrbanPop: int  58 48 80 50 91 78 77 72 80 60 ...
##  $ Rape    : num  21.2 44.5 31 19.5 40.6 38.7 11.1 15.8 31.9 25.8 ...
```
]

--

`summary()` displays summary information&lt;sup&gt;1&lt;/sup&gt;:

.text-85[

```r
summary(USArrests)
```

```
##      Murder          Assault         UrbanPop          Rape      
##  Min.   : 0.800   Min.   : 45.0   Min.   :32.00   Min.   : 7.30  
##  1st Qu.: 4.075   1st Qu.:109.0   1st Qu.:54.50   1st Qu.:15.07  
##  Median : 7.250   Median :159.0   Median :66.00   Median :20.10  
##  Mean   : 7.788   Mean   :170.8   Mean   :65.54   Mean   :21.23  
##  3rd Qu.:11.250   3rd Qu.:249.0   3rd Qu.:77.75   3rd Qu.:26.18  
##  Max.   :17.400   Max.   :337.0   Max.   :91.00   Max.   :46.00
```
]

.footnote[[1] Note R `summary()` provides different information for different types of objects!]

---
class: inverse
# Indexing and Subsetting
## Base R

---

# Indices and Dimensions

In base R, there are two main ways to access object elements: square brackets (`[]` or `[[]]`) and `$`. How you access an object depends on its *dimensions*.

--

Dataframes have *2* dimensions: **rows** and **columns**. Square brackets allow us to numerically **subset** in the format of `object[row, column]`. Leaving the row or column place empty selects *all* elements of that dimension.

.small[

```r
USArrests[1,] # First row
```

```
##         Murder Assault UrbanPop Rape
## Alabama   13.2     236       58 21.2
```
]
--
.small[

```r
*USArrests[1:3, 3:4] # First three rows, third and fourth column
```

```
##         UrbanPop Rape
## Alabama       58 21.2
## Alaska        48 44.5
## Arizona       80 31.0
```
]

.pull-right[
.footnote[
The **colon operator** (`:`) generates a vector using the sequence of integers from its first argument to its second. `1:3` is equivalent to `c(1,2,3)`.
]
]
---

# Dataframes and Names

Columns in dataframes can also be accessed using their names with the `$` extract operator. This will return the column as a vector:


```r
USArrests$UrbanPop[1:10]
```

```
##  [1] 58 48 80 50 91 78 77 72 80 60
```

--

Note here I *also* used brackets to select just the first 10 elements of that column.

You can mix subsetting formats! In this case I provided only a single value (no column index) because **vectors** have *only one dimension* (length).

If you try to subset something and get a warning about "incorrect number of dimensions", check your subsetting!


---

# Indexing by Expression

We can also index using expressions—logical *tests*.


```r
USArrests[USArrests$Murder &gt; 15, ]
```

```
##             Murder Assault UrbanPop Rape
## Florida       15.4     335       80 31.9
## Georgia       17.4     211       60 25.8
## Louisiana     15.4     249       66 22.2
## Mississippi   16.1     259       44 17.1
```

---

# How Expressions Work

What does `USArrests$Murder &gt; 15` actually do? 

--


```r
USArrests$Murder &gt; 15
```

```
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
## [11] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [21] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [31] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [41] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
```

--

It returns a vector of `TRUE` or `FALSE` values.

When used with the subset operator (`[]`), elements for which a `TRUE` is given are returned while those corresponding to `FALSE` are dropped.

---

# Logical Operators

We used `&gt;` for testing "greater than": `USArrests$Murder &gt; 15`.

--

There are many other [logical operators](http://www.statmethods.net/management/operators.html):

--
* `==`: equal to

--
* `!=`: not equal to

--
* `&gt;`, `&gt;=`, `&lt;`, `&lt;=`: less than, less than or equal to, etc.

--
* `%in%`: used with checking equal to one of several values

--

Or we can combine multiple logical conditions:

* `&amp;`: both conditions need to hold (AND)
--

* `|`: at least one condition needs to hold (OR)
--

* `!`: inverts a logical condition (`TRUE` becomes `FALSE`, `FALSE` becomes `TRUE`)

--

Logical operators are one of the foundations of programming. You should experiment with these to become familiar with how they work!

---

# Sidenote: Missing Values

Missing values are coded as `NA` entries without quotes:


```r
vector_w_missing &lt;- c(1, 2, NA, 4, 5, 6, NA)
```

Even one `NA` "poisons the well": You'll get `NA` out of your calculations unless you remove them manually or use the extra argument `na.rm = TRUE` in some functions:


```r
mean(vector_w_missing)
```

```
## [1] NA
```

--

We can take missings (`NA`) and remove (`rm`) them:


```r
mean(vector_w_missing, na.rm=TRUE)
```

```
## [1] 3.6
```

---
# Finding Missing Values

**WARNING:** You can't test for missing values by seeing if they "equal" (`==`) `NA`:


```r
vector_w_missing == NA
```

```
## [1] NA NA NA NA NA NA NA
```

--

But you can use the `is.na()` function:


```r
is.na(vector_w_missing)
```

```
## [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
```

--

We can use subsetting to get the equivalent of `na.rm=TRUE`:


```r
*mean(vector_w_missing[!is.na(vector_w_missing)])
```

```
## [1] 3.6
```


.footnote[
`!` *reverses* a logical condition. Read the above as "subset to *not* `NA`"
]

---
class: inverse

&amp;nbsp;

&amp;nbsp;


![](img/swirl_new_large_final.png)

---

# Installing Packages

Let's give you a way to practice basics on your own. To do this, we'll want to install a **package** called `swirl`

Packages contain premade functions and/or data we can use. R's strength comes from packages!

In the console, type `install.packages("swirl")`.

--

* Note that *the name of a package to be installed must be in quotes*. This is because the name here is a search term (text), not an object!.

--

* Once you install a package, you don't need to re-install it until you update R. *Consequently, you should not include* `install.packages()` *in a R script!*

--

We can load packages like `swirl` using the `library()` function.


```r
library(swirl)
```

---
class: inverse

# For Next Time

* [Check out the IQA website](https://clanfear.github.io/ioc_iqa/_site/)

* Try out some `swirl` tutorials
   * Use `library(swirl)` to load the package
   * Once loaded, use `swirl()` to start the tutorial interface
      * *READ THE INSTRUCTIONS*
   * Try out `R Programming` lessons---we're up to the equivalent of about 5

* Read first two chapters of Kaplan (2022)
   * Try to run the code in Chapter 2 as you read

If you run into R problems you can't get past quickly, send an email or just set it aside until next week!
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../assets/cam_macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "tomorrow-night-bright",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
