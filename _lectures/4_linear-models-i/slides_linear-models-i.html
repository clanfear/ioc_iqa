<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Linear Models I</title>
    <meta charset="utf-8" />
    <meta name="author" content="Charles Lanfear" />
    <script src="libs/header-attrs-2.17/header-attrs.js"></script>
    <link rel="stylesheet" href="../assets/cam-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, top, title-slide

.title[
# Linear Models I
]
.subtitle[
## IQA Lecture 4
]
.author[
### Charles Lanfear
]
.date[
### 2 Nov 2022<br>Updated: 01 Nov 2022
]

---





# Things to include

Categorical predictors

* Binary
* 3+ category

Controlling for variables

* Demeaning with dummies
* Partial correlations (is that pairs plot?)


* Stats
   * TTest is an lm() with 2 category (binary) predictor
   * ANOVA is an lm() with 3+ category predictor

* Code




---

# Setup

Like usual, let's start by loading the communities data

First, let's convert our categorical variables to factors with appropriate levels

.text-85[

```r
library(tidyverse)
communities &lt;- 
  read_csv("https://clanfear.github.io/ioc_iqa/_data/communities.csv") |&gt;
  mutate(across(c(incarceration, disadvantage), 
                ~ factor(., levels = c("Low", "Medium", "High"))),
         area = factor(area, levels = c("Rural", "Urban")))
```
]

We can use `across()` as a shortcut to perform the same operation on multiple variables

--

This is the same as doing this:

.text-85[

```r
mutate(incarceration = 
         factor(incarceration, levels = c("Low", "Medium", "High")), 
       disadvantage = 
         factor(disadvantage, levels = c("Low", "Medium", "High")))
```
]

---

# Another `across()`

You can also give `across()` a list of functions and it will apply them to each variable


```r
communities |&gt;
  group_by(incarceration) |&gt;
  summarize(across(c(crime_rate, pop_density), 
                   list(mu = ~mean(.), 
                        sd = ~sd(.))))
```

```
## # A tibble: 3 × 5
##   incarceration crime_rate_mu crime_rate_sd pop_density_mu pop_den…¹
##   &lt;fct&gt;                 &lt;dbl&gt;         &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;
## 1 Low                    17.7          16.1           12.8      4.87
## 2 Medium                 20.9          18.0           14.2      5.40
## 3 High                   37.0          25.3           17.5      5.75
## # … with abbreviated variable name ¹​pop_density_sd
```

This calculated a `mean()` and `sd()` each for `crime_rate` and `pop_density` within each level of `incarceration` with very little code!

---
class: inverse

# Linear Models

### Different predictors

---

# Continuous



.pull-left[

```r
lm(crime_rate ~ pop_density, 
   data = communities) |&gt; 
  coef() # extract coefficients
```

```
## (Intercept) pop_density 
##  -20.776945    3.093886
```

We've seen a lot of linear models with continuous predictors

It is easy to visualize what the model is doing with a line laid over a scatterplot
]

.pull-right[

```r
ggplot(communities, 
       aes(x = pop_density, 
           y = crime_rate)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-5-1.svg)&lt;!-- --&gt;
]




---

# Dummy Variables

What is a regression model doing when you have a binary predictor?

--



.pull-left[

```r
lm(crime_rate ~ area, 
   data = communities) |&gt;
  coef()
```

```
## (Intercept)   areaUrban 
##    10.43129    30.18226
```

The data look weird and `geom_smooth()` doesn't even do anything!

Why do the data look like this?
]

.pull-right[

```r
ggplot(communities, 
       aes(x = area, 
           y = crime_rate)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-7-1.svg)&lt;!-- --&gt;
]





---

# A Slight Modification

.pull-left[

```r
lm(crime_rate ~ area, 
   data = communities) |&gt;
  coef()
```

```
## (Intercept)   areaUrban 
##    10.43129    30.18226
```

It turns out the linear model actually treats a binary variable as a numeric one that takes values of 0 or 1.

When `areaUrban` is 0 (`area` is `"Rural"`) the mean `crime_rate` is `\(10.43\)`

When `areaUrban` is 1 (`area` is `"Urban"`) the mean is `\(10.43 + 30.18 = 40.61\)`

]
.pull-right[

```r
communities |&gt; 
  mutate(urban = 
    as.numeric(area=="Urban")) |&gt;
  ggplot(aes(x = urban, 
             y = crime_rate)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-9-1.svg)&lt;!-- --&gt;
]





---

# Mean Differences



.pull-left[
Linear regression is just estimating means by group!


```r
dummy_model &lt;- 
  lm(crime_rate ~ area, 
     data = communities)
dummy_model |&gt; coef()
```

```
## (Intercept)   areaUrban 
##    10.43129    30.18226
```

The intercept is the average crime rate for rural places

The value for `areaUrban` is the **difference** between rural and urban places

]
.pull-right[
Compare the model to group-specific average crime rates:

```r
communities |&gt;
  group_by(area) |&gt;
  summarize(crime_rate = 
              mean(crime_rate))
```

```
## # A tibble: 2 × 2
##   area  crime_rate
##   &lt;fct&gt;      &lt;dbl&gt;
## 1 Rural       10.4
## 2 Urban       40.6
```

`\(\text{Urban} = 40.61 = 10.43 + 30.18\)`

]

These are saying the exact same thing!


---

# Hypothesis Testing

Significance testing with dummy variables works like any others

.text-85[

```r
summary(dummy_model)$coefficients
```

```
##             Estimate Std. Error  t value     Pr(&gt;|t|)
## (Intercept) 10.43129   1.270202  8.21231 6.660396e-15
## areaUrban   30.18226   1.814574 16.63325 2.123665e-44
```
]

--

This is *identical* to a two-sample t-test!

.text-85[

```r
t.test(crime_rate ~ area, data = communities, var.equal=TRUE)
```

```
## 
## 	Two Sample t-test
## 
## data:  crime_rate by area
## t = -16.633, df = 298, p-value &lt; 2.2e-16
## alternative hypothesis: true difference in means between group Rural and group Urban is not equal to 0
## 95 percent confidence interval:
##  -33.75326 -26.61125
## sample estimates:
## mean in group Rural mean in group Urban 
##            10.43129            40.61355
```
]

.pull-right-40[
.footnote[
This is a significance test for a difference in group means—the same as our dummy variable model!
]
]

---

# More Categories

When a variable has more than two categories, all but one category is converted to a mutually exclusive binary variable

.pull-left[

```r
lm(crime_rate ~ incarceration, 
   data = communities) |&gt; 
  broom::tidy() |&gt; 
  select(term, estimate)
```

```
## # A tibble: 3 × 2
##   term                estimate
##   &lt;chr&gt;                  &lt;dbl&gt;
## 1 (Intercept)            17.7 
## 2 incarcerationMedium     3.22
## 3 incarcerationHigh      19.3
```
]
.pull-right[

```r
communities |&gt;
  group_by(incarceration) |&gt;
  summarize(crime_rate = 
              mean(crime_rate))
```

```
## # A tibble: 3 × 2
##   incarceration crime_rate
##   &lt;fct&gt;              &lt;dbl&gt;
## 1 Low                 17.7
## 2 Medium              20.9
## 3 High                37.0
```
]

Here our intercept represent the mean when `incarceration` is neither `"Medium"` nor `"High"`. Our **reference category** is `"Low"`

---

# ANOVA

Some of you may be familiar with ANOVA for analysing how 3+ category variables relate to a continuous outcome

.text-85[

```r
aov(crime_rate ~ incarceration, data = communities) |&gt; summary()
```

```
##                Df Sum Sq Mean Sq F value  Pr(&gt;F)    
## incarceration   2  20991   10496   25.79 4.7e-11 ***
## Residuals     297 120866     407                    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```
]

--

Turns out ANOVA is just a standard linear model with a categorical variable


```r
aov(crime_rate ~ incarceration, data = communities) |&gt; coef()
```

```
##         (Intercept) incarcerationMedium   incarcerationHigh 
##           17.726374            3.217159           19.265125
```

--

Until you get to very advanced methods (i.e., mixed effects models), ANOVA is just a less flexible linear model with more complicated terminology

---

# As an `lm()`

.text-85[

```r
summary(crime_rate ~ incarceration, data = communities)
```

```
##  Length   Class    Mode 
##       3 formula    call
```
]

.footnote[
Note the F-statistic for the regression is the F value for the ANOVA
]

---
class: inverse

# Controls

&amp;nbsp;

&amp;nbsp;

![:width 50%](img/yoda.gif)

---

# Controlling for Variables

Remember that we control for variables for the purpose of **identifying** something we're interested in

--

In causal research, this is some **treatment effect**.

* In the following examples, we'll assume we want to identify `\(X \rightarrow Y\)`

--

In other cases, it may just be some association we're interested in.

--

To know if a control does what you want (e.g., closes a back door), it is important to understand:

* What including that control implies for your model
* Exactly what including it really does numerically



---

# Categorical Controls



We include a categorical control `\(Z\)` if we believe some of `\(X\)` and `\(Y\)`'s apparent relationship is due to *some `\(Z\)` groups having different average levels of X and Y*

--

If we remove group-specific averages of both X and Y, we can get rid of that

--

.pull-left[
.text-85[

```r
lm(crime_rate ~ pop_density + area,
   data = communities) |&gt; 
  broom::tidy() |&gt;
  select(term, estimate)
```

```
## # A tibble: 3 × 2
##   term        estimate
##   &lt;chr&gt;          &lt;dbl&gt;
## 1 (Intercept)   -23.0 
## 2 pop_density     3.36
## 3 areaUrban      -3.39
```
]

Note the identical `pop_density` slopes!
]
.pull-right[
.text-85[

```r
residualized_data &lt;- communities |&gt;
  group_by(area) |&gt;
* mutate(pop_density_res =
*     pop_density - mean(pop_density),
*        crime_rate_res  =
*     crime_rate - mean(crime_rate))
*lm(crime_rate_res ~ pop_density_res,
   data = residualized_data)  |&gt; 
  broom::tidy() |&gt; select(term, estimate)
```

```
## # A tibble: 2 × 2
##   term            estimate
##   &lt;chr&gt;              &lt;dbl&gt;
## 1 (Intercept)     4.03e-15
## 2 pop_density_res 3.36e+ 0
```
]
]

--

.text-center[
This is residualising our data—what does that mean?
]

---

# Residuals

Residuals are the difference between model predictions and the actual data

.text-85[

```r
lm_res &lt;- lm(crime_rate ~ pop_density, data = communities) |&gt; broom::augment()
```
]

.pull-left[
.text-85[

```r
ggplot(lm_res, 
    aes(x = pop_density, 
        y = crime_rate)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-22-1.svg)&lt;!-- --&gt;
]
]
.pull-right[
.text-85[

```r
ggplot(lm_res,
    aes(x = pop_density, 
*       y = .resid)) +
  geom_point() + 
  geom_smooth(method = "lm")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-23-1.svg)&lt;!-- --&gt;
]
]

--

.text-center[
When we residualise, we're left with what our predictors *don't explain*
]

---

# Visualising It

.pull-left[

```r
ggplot(communities, 
       aes(x = pop_density, 
           y = crime_rate, 
           color = area)) + 
  geom_point() + 
  geom_smooth(method = "lm", 
              color = "black") 
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-24-1.svg)&lt;!-- --&gt;

]
.pull-right[

```r
ggplot(residualized_data, 
*      aes(x = pop_density_res,
*          y = crime_rate_res,
           color = area))+ 
  geom_point() + 
  geom_smooth(method = "lm",
              color = "black")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-25-1.svg)&lt;!-- --&gt;
]

Rural and urban data points now occupy a similar area due to subtracting their average `\(X\)` and `\(Y\)` values

---

# `car::avPlot()`

This type of plot is sometimes called an **added variable plot** and there are existing functions to produce it for us

.pull-left[

```r
ggplot(residualized_data, 
       aes(x = pop_density_res,
           y = crime_rate_res))+ 
  geom_point() + 
  geom_smooth(method = "lm")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-26-1.svg)&lt;!-- --&gt;
]
.pull-right[

```r
lm(crime_rate ~ pop_density + 
   area, 
   data = communities) |&gt; 
  car::avPlot(
    variable = "pop_density")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-27-1.svg)&lt;!-- --&gt;
]

These show the regression line *controlling for all other included variables*

---

# Continuous Variables

We include continuous controls if some of X and Y's relationship is because Z makes X and Y higher/lower

If we remove variation in X and Y due to Z, we can get rid of that

Here we use bivariate models predicting what we want to residualize

.text-85[

```r
residualized_data &lt;- communities %&gt;%
  mutate(area_num       = as.numeric(area == "Urban"),
*        crime_rate_res = residuals(lm(crime_rate ~ pop_density, data = .)),
*        area_res       = residuals(lm(area_num ~ pop_density, data = .)))
```
]

.pull-left[
.text-85[

```r
lm(crime_rate ~ pop_density + area, 
   data = communities) |&gt; 
  broom::tidy() |&gt; select(term, estimate)
```

```
## # A tibble: 3 × 2
##   term        estimate
##   &lt;chr&gt;          &lt;dbl&gt;
## 1 (Intercept)   -23.0 
## 2 pop_density     3.36
## 3 areaUrban      -3.39
```

]
]

.pull-right[
.text-85[

```r
*lm(crime_rate_res ~ area_res,
*  data = residualized_data) |&gt;
  broom::tidy() |&gt; select(term, estimate)
```

```
## # A tibble: 2 × 2
##   term         estimate
##   &lt;chr&gt;           &lt;dbl&gt;
## 1 (Intercept)  2.61e-16
## 2 area_res    -3.39e+ 0
```

]
]


---

# Visualising It

.pull-left[

```r
ggplot(residualized_data, 
       aes(x = area_num, 
           y = crime_rate, 
           color = area)) + 
  geom_point() + 
  geom_smooth(method = "lm", 
              color = "black") 
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-31-1.svg)&lt;!-- --&gt;

]
.pull-right[

```r
ggplot(residualized_data, 
*      aes(x = area_res,
*          y = crime_rate_res,
           color = area))+ 
  geom_point() + 
  geom_smooth(method = "lm",
              color = "black")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-32-1.svg)&lt;!-- --&gt;
]

Rural and urban data points now occupy a similar area due to subtracting their average `\(X\)` and `\(Y\)` values

---

# wat

Yep, that's not a mistake

.pull-left[

```r
ggplot(residualized_data, 
*      aes(x = area_res,
*          y = crime_rate_res,
           color = area))+ 
  geom_point() + 
  geom_smooth(method = "lm",
              color = "black")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-33-1.svg)&lt;!-- --&gt;
]

.pull-right[

```r
lm(crime_rate ~ pop_density + 
       area, 
   data = communities) |&gt; 
    car::avPlot(
        variable = "areaUrban")
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-34-1.svg)&lt;!-- --&gt;

]

---

# Collider Bias



```r
ex_data &lt;- tibble(Skill = runif(1000, 0, 10), 
                  Frequency = runif(1000, 0, 10), 
                  Who = c(rep("Arrested", 500), 
                          rep("Everyone", 500))) |&gt;
  filter(Who == "Everyone" | (10 + (-1*Skill) + Frequency &gt; 10))

ex_data |&gt; 
  ggplot(aes(x = Skill, y = Frequency, color = Who)) + 
  geom_point() + 
  labs(x = "Skill at Crime", y = "Frequency of Crime") +
  geom_smooth(method = "lm", formula = "y~x", se = FALSE, color = "black") + 
  facet_wrap(~Who)  + 
  theme_minimal(base_size = 16) + 
  theme(legend.position = "none",
        panel.spacing.x = unit(0.4, "in"))
```

![](slides_linear-models-i_files/figure-html/unnamed-chunk-35-1.svg)&lt;!-- --&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../assets/cam_macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "tomorrow-night-bright",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
